= Minion

#TODO: We have to update the introduction here. Make it message broker generic.
       The introduction should be rewritten to answer the following questions: +
         * How can a Minion help me and when do I need a Minion +
         * What is required to deploy Minions#

Minion gives the ability to monitor devices and applications which are in isolated networks and hard to reach from a central {page-component-title} Core instance.
Maintaining a large set of _Firewall_ rules to allow a variety of management protocols is sometimes tedious and hard to set up.
Communicating with managed devices over unreliable networks and the use of _UDP_ based management protocols can also be difficult to maintain.
Deploying a Minion can be used to address these issues.

A Minion can be used when a central {page-component-title} Core instance can't reach all devices for monitoring.
Furthermore it simplifies the network communication to the message broker and the REST endpoint.

The network area where access to managed network devices and applications is allowed can be modeled in a _Location_.
Monitored _Nodes_ and _IP Services_ are associated to _Locations_ and are defined during _Provisioning_.
Each Minion is configured with a _Location_ and all _Nodes_ and _IP Services_ in the same _Location_ are monitored through this Minion.

._Nodes_ with _Minions_ in _Locations_
image::deployment/minion/location.png[]

Every _Node_ created in {page-component-title} is by default created in the _Location_ named _Default_.
All _Nodes_ and _Services_ in the _Default Location_ are handled by the central {page-component-title} instance itself.
For each branch office in an isolated network, a _Location_ is defined.
The _Minion_ has a configuration property for the _Location_ and will register itself to the {page-component-title} instance on startup.

The _Provisioning System_ allows to associate _Nodes_ to a _Location_.
{page-component-title} will delegate monitoring requests for _Nodes_ in the specified _Locations_ to the registered _Minions_ and uses them as a proxy.

Figure <<gi-install-minion-communication, Minion communication>> gives a more detailed overview about the communication between an {page-component-title} instance and a _Minion_.

.Minion communication
image::deployment/minion/communication.png[]

#TODO: This is all installation specific and already covered#

The _Minion_ needs a configuration which requires at minimum the following information:

* An unique identifier (`id`) for this specific _Minion_
* Monitoring _Location_ name (`location`) this _Minion_ is responsible
* The communication endpoints (`broker-url` and `http-url`) for the central {page-component-title} instance

The configuration resides in a property file in `$\{MINION_HOME}/etc/org.opennms.minion.controller.cfg`.
When the minimal configuration is set up the _Minion_ can be started and initially connects to the central {page-component-title} instance and identifies itself with his unique _ID_.

NOTE: The unique _ID_ is generated when the packages get installed `/usr/bin/uuidgen -t` and is used if no _ID_ is set manually.
On upgrade the _ID_ is not updated.

By default the _Minion_ will be automatically provisioned as a _Node_ in the {page-component-title} instance and get automatically monitored with the _Minion-Heartbeat_ service.
The _Minion_ sends heart beat messages to ensure it is running and functioning properly in this network area.

The specific management protocol messages, e.g. _SNMP_, _ICMP_, are piped through an _ActiveMQ_ messaging communication channel and are executed by a _Minion_.
Responses are forwarded to the central {page-component-title} instance and are processed accordingly.

_Minions_ can be installed on every system that is able to communicate with these two endpoints:

* The _OpenNMS ReST Interface_, by default _TCP_ port 8980
* The _ActiveMQ_ broker used by {page-component-title}, by default _TCP_ port 61616

#TODO: This here might make sense to describe why you probably want a Minion#

The following management protocols are currently supported in a _Minion_ proxy scenario:

* Receive _Syslog_ messages and forward them through _ActiveMQ_ to a central {page-component-title} instance
* Receive _SNMP Traps_ and forward them through _ActiveMQ_ to a central {page-component-title} instance
* Act as a proxy for _SNMP_ performance data collections
* Act as a proxy for _Service Monitors_ to test availability and measure response times from applications

#TODO: This is not true anymore#
IMPORTANT: Packages are only available for _RHEL_-based systems (_RPMS_).

#TODO: We can remove this warning here it is a requirement in the install section#
WARNING: To avoid issues, make sure the _Minion_ and the instance of {page-component-title} have the same version.

image::deployment/minion/minion-communication.png[]

image::deployment/minion/minion-communication.png[]

image::deployment/minion/setup-minion-kafka.png[]
